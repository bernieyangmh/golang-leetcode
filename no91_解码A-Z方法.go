// 一条包含字母 A-Z 的消息通过以下方式进行了编码：
// 'A' -> 1
// 'B' -> 2
// ...
// 'Z' -> 26
// 给定一个只包含数字的非空字符串，请计算解码方法的总数。
// 示例 1:
// 输入: "12"
// 输出: 2
// 解释: 它可以解码为 "AB"（1 2）或者 "L"（12）。
// 示例 2:
// 输入: "226"
// 输出: 3
// 解释: 它可以解码为 "BZ" (2 26), "VF" (22 6), 或者 "BBF" (2 2 6) 。
package main

func main() {
	println(numDecodings("226"))

}

// 动态规划
// dp[i] = dp[i-1] + dp[i-2]
// 假如从深圳到北京可以经过武汉和上海两条路，而从武汉到北京有 8 条路，从上海到北京有 6 条路。那么从深圳到北京就有 8 + 6 = 14 条路

// 1.如果当前数字是0, 前一个数字是1或2, 到该数字的总数等于前两个的总数 eg: 310 -> [3, 10]  0只能和前一个数字组合,10只有唯一路径
// 如果不是,不能组成编码,xxx70xxx 没有字母是70,也没有字母以0开头, 总数是0,直接返回
// 2.如果当前数字的前一个是1, 当前总数是前两个总数之和; eg:125->[1,25], [12, 5]
// 3.如果当前数字的前一个是2, 当前数组在‘1’-‘6’之间,同上
// 其他情况,被唯一编码,不增加总数 eg: 152 -> [15, 2]
func numDecodings(s string) int {
	if s[0] == '0' {
		return 0
	}
	// 初始化,dp[-1]=dp[0]=1
	var (
		pre  = 1
		curr = 1
	)
	for i := 1; i < len(s); i++ {
		
		var tmp = curr
		if s[i] == '0' {
			if s[i-1] == '1' || s[i-1] == '2' {
				curr = pre
			} else {
				return 0
			}
		} else if s[i-1] == '1' || (s[i-1] == '2' && s[i] >= '1' && s[i] <= '6') {
			curr = curr + pre
		}
		pre = tmp
	}
	return curr
}
