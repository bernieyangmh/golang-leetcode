// 给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。
// 注意:
// 每个数组中的元素不会超过 100
// 数组的大小不会超过 200
// 示例 1:
// 输入: [1, 5, 11, 5]
// 输出: true
// 解释: 数组可以分割成 [1, 5, 5] 和 [11].
// 示例 2:
// 输入: [1, 2, 3, 5]
// 输出: false
// 解释: 数组不能分割成两个元素和相等的子集.
package main

import (
	"fmt"
)

func main() {

	fmt.Println(0^0)


}

// 动态规划,类似背包问题
// 总和必然是偶数才能被分成两分, 我们能找到和的一半就说明可以分开
// [0,i]个数,它能组成的和是自身及前一个的子集.
// eg [1,5,11,5]half=11		[1] ->1  [1,5]->1,5,6 [1,5,11]-> 1,5,6,11 [1,5,11,5]->1,5,6,10,11
func canPartition(nums []int) bool {
	var sum int
	// 算出总和
	for i := 0; i < len(nums); i++ {
		sum += nums[i]
	}
	// 奇数必然没有
	if sum&1 == 1 {
		return false
	}
	half := sum / 2
	dp := make([]bool, half+1)
	dp[0] = true

	for i := 0; i < len(nums); i++ {
		// 从一半开始,先前递减,直到当前数字(包含5的集合,和必然大于5,小的就不用算)
		for j := half; j >= nums[i]; j-- {
			// 数字直接就是一半,可以分两个
			if dp[half] {
				return true
			}
			// 如果一个j,比如6, 在之前的集合就能被组成,现在集合多了11,一样可以组成
			// 如果一个和之前存在,比如1,那么nums[i]是5时,6就可以被组成
			dp[j] = dp[j] || dp[j-nums[i]]
		}
	}
	return dp[half]
}
