// 给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, ...）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。
// 示例 1:
// 输入: n = 12
// 输出: 3
// 解释: 12 = 4 + 4 + 4.
// 示例 2:
// 输入: n = 13
// 输出: 2
// 解释: 13 = 4 + 9.
package main

import (
	"fmt"
)

func main() {
	numSquares(1024)

}
// 动态规划
// eg:13. 他只可能被1,4,9组成,扣掉1,4,9之后是 12, 9, 4 
// 我们分别要看12, 9, 4 他们的组成, 12->[1/11,4/8,9/3] 9->[1/8, 4/5, 9/0] 4->[1/3, 4/0]
// 每次我们都想要组成的个数尽可能的小,这个最好的结果取决于当前数扣掉完全平方数后的差,差的最好结果 
// 当前的结果取决于上一次的最好结果,这就想到动态规划
// 翻译成数学公式 bese(dp[i], dp[i - j*j]+1) 
// 为什么加1? 4是最小的非1无完全数,也就是说任何数的最终次数,都要递归 取决到1-4上.
func numSquares(n int) int {
	dp := make([]int, n+1)
	for i := 1; i <= n; i++ {
		dp[i] = i
		for j := 1; i-j*j >= 0; j++ {
			fmt.Println(i, j*j)
			dp[i] = min(dp[i], dp[i-j*j]+1)
		}

	}
	fmt.Println(dp)
	return dp[n]
}

func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}
